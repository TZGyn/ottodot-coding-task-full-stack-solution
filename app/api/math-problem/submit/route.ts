import { gemini } from '@/lib/ai/gemini'
import { nanoid } from '@/lib/nanoid'
import { supabase } from '@/lib/supabaseClient'
import { generateObject } from 'ai'
import { NextResponse } from 'next/server'
import z, { success } from 'zod'

export const POST = async (request: Request) => {
	const body = await request.json()

	const parsed = z
		.object({
			sessionId: z.string(),
			problem_text: z.string(),
			final_answer: z.number(),
			answer: z.string(),
		})
		.safeParse(body)

	if (!parsed.success) {
		return NextResponse.json(
			{
				success: false,
				error: {
					message: 'Invalid payload',
				},
			},
			{ status: 400 }
		)
	}

	const { object } = await generateObject({
		model: gemini('gemini-2.0-flash'),
		schema: z.object({
			feedback_text: z.string(),
			hint: z.string(),
			is_correct: z.boolean(),
		}),
		messages: [
			{
				role: 'system',
				content: `
					You are a mathematic teacher, you will be giving feedbacks to solutions of mathematical problems.
					Your students are primary 5, so your feedbacks must be easily digestible and easy to follow so their don't have trouble learning from the feedbacks.
					Make sure to guide the students to the answer instead of giving them out straight away

					You will be given the question as well as the correct answer generated by a previous model.
					Then you will be presented the user's answer
					There might be times where the generated answer is incorrect
					You must make sure that you return correct only when the user's answer is correct

					You may provide hint for the user as well
				`,
			},
			{
				role: 'user',
				content: [
					{
						text: `
							Question: ${parsed.data.problem_text}
							Answer (generated by gemini): ${parsed.data.final_answer}
						`,
						type: 'text',
					},
					{
						text: `Answer by user: ${parsed.data.answer}`,
						type: 'text',
					},
				],
			},
		],
	})

	try {
		const res = await supabase.from('math_problem_submissions').insert({
			session_id: parsed.data.sessionId,
			user_answer: parsed.data.answer,
			is_correct: object.is_correct,
			feedback_text: object.feedback_text,
		})
		console.log(res)
	} catch (error) {
		console.log(error)
	}

	return NextResponse.json(
		{
			success: true,
			feedback: object.feedback_text,
			isCorrect: object.is_correct,
			hint: object.hint,
		},
		{ status: 200 }
	)
}
